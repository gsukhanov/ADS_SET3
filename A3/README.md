# A3. Анализ INTROSORT.

В папке содержится файл `A3.cpp`. Скомпилировав его и запустив с опциями resultx, breakpoint, size можно получить `.csv` файл с названием `resultx.csv`, в котором находятся результаты работы `INTROSORT` с точкой применения `INSERTION SORT` равной breakpoint на массиве размера size. Для получения чистого `QUICKSORT` значение breakpoint необходимо выставить равным 1.

Все данные собирались с использованием ключа компиляции `-O3`.

Мной было принято решение ограничить размер массивов 20000 элементов для `QUICKSORT`, так как время на массивах размеров больше 60000 приближалось к 1 секунде, и таким образом сбор данных для одного файла занял бы более часа, которого у меня не было.

Собрав все данные в одну таблицу `A3.xlsx` были составлены 3 графика:

1. `INTROSORT.pdf` - содержит сравнение скоростей сортировки различных массивов с применением `INTROSORT`.
2. `QUICKSORT.pdf` - содержит сравнение скоростей сортировки различных массивов с применением `QUICKSORT`.
3. `Сравнение алгоритмов на случайном массиве.png` - содержит сравнение скоростей алгоритмов на случайном массиве. (случайно сохранил как `.png`)

Из данных можно сделать следующие выводы:

1) `INTROSORT` многократно эффективнее `QUICKSORT` почти на любых входных данных.
2) Алгоритмы стохастические, что приводит к редким серьёзным скачкам времени.
3) `QUICKSORT` занимает приблизительно одинаковое время на массивах любого размера, причем дольше всего - на развёрнутых. В то же время `INTROSORT` по какой-то причине занимает максимальное время на случайном массиве, а на развёрнутом затрачивает время, близкое к почти отсортированному.
4) `QUICKSORT` имеет заметно нелинейную сложность даже на размере входных данных от 100 до 20000, а `INTROSORT` ведёт себя неотличимо от линейного алгоритма.
